using fNbt;using Minecraft.City.Datapack.Generator.Builder.Jigsaw;using Minecraft.City.Datapack.Generator.Models.IlNodes;using Minecraft.City.Datapack.Generator.Models.TemplatePool;namespace Minecraft.City.Datapack.Generator.Builder.Roads;public class RoadSection(	NbtCompound rootTag,	IlRect? boundingBox = null,	Dictionary<IlPoint, Jigsaw.Jigsaw>? rootJigsaws = null,	int index = -1)	: AbstractSection(rootTag, boundingBox, rootJigsaws){	private int _nextSubsectionIndex;	public int Index { get; } = index;	private bool HasTile(int x, int z)	{		if (x < 0 || z < 0)		{			return false;		}		if (x >= MaxX || z >= MaxZ)		{			return false;		}		return TileMap[x, z];	}	public bool HasSubSections => Jigsaws.Count > 0;	public RoadSection TakeSubSection()	{		var first = Jigsaws.First().Value;		var coordinates = GetRect(first.Compound);		var subsection = new RoadSection(RootTag, coordinates, Jigsaws, _nextSubsectionIndex++);		var toRemove = Jigsaws			.Where(j => coordinates.PointInside(j.Key))			.Select(j => j.Key)			.ToList();		foreach (var point in toRemove)		{			Jigsaws.Remove(point);		}		coordinates.ForEach((x, z) => TileMap[x, z] = false);		return subsection;	}	public void UpdateJigsaws(string baseFileName, Dictionary<IlPoint, int> jigsawPointToIndex, string typeName, string outsideName)	{		FlipPointedToJigsaws();		foreach (var jigsaw in Jigsaws.Values)		{			jigsaw.SetJigsawName($"poke-cities:{baseFileName}-{Index}-{jigsaw.OriginalLocation.SerializedString}");			if (				jigsaw.PointingToLocation == null ||				!jigsawPointToIndex.TryGetValue(jigsaw.PointingToLocation, out var pointIndex)			)			{				if (jigsaw.PointsToOutside)				{					jigsaw.SetJigsawPool($"poke-cities:{outsideName}");					jigsaw.SetJigsawTarget($"poke-cities:{outsideName}-start");				}				if (jigsaw.PointsFromOutside)				{					jigsaw.SetJigsawName($"poke-cities:{typeName}-start");				}				continue;			}			jigsaw.SetJigsawPool($"poke-cities:{baseFileName}-{pointIndex}");			jigsaw.SetJigsawTarget(				$"poke-cities:{baseFileName}-{pointIndex}-{jigsaw.PointingToLocation.SerializedString}");		}	}	private void FlipPointedToJigsaws()	{		var states = RootTag.GetTypeStateIds();		foreach (			var jigsaw in Jigsaws.Values				.Where(jigsaw => 					jigsaw.PointingToLocation == null &&					jigsaw.PointsToOutside == false				)			)		{			jigsaw.Flip(states);		}	}	private IlRect GetRect(NbtCompound jigsaw)	{		// Get pass one delta		var (xChange, zChange) = jigsaw.GetJigsawTileType(RootTag).GetOffsetForTileType();		if (xChange == zChange)		{			throw new ArgumentException("tile was not a jigsaw");		}		var path = new List<IlPoint>();		var location = jigsaw.GetNbtPosition();		var oppositeBoundaryCandidate1 = GetBoundaryInDirection(location.x, location.z, xChange, zChange, true, path);		var oppositeBoundaryCandidate2 = GetBoundaryInDirection(location.x, location.z, -xChange, -zChange, true, path);		var oppositeBoundary = oppositeBoundaryCandidate1.Equals(new IlPoint(location.x, location.z))			? oppositeBoundaryCandidate2			: oppositeBoundaryCandidate1;		path.Add(oppositeBoundary);		var crossXChange = Math.Abs(zChange);		var crossZChange = Math.Abs(xChange);		var mins = path.Select(i => GetBoundaryInDirection(i.X, i.Z, -crossXChange, -crossZChange, false));		var maxes = path.Select(i => GetBoundaryInDirection(i.X, i.Z, crossXChange, crossZChange, false));		var minX = 0;		var minZ = 0;		var maxX = 0;		var maxZ = 0;		//horizontal		if (xChange != 0)		{			minX = Math.Min(location.x, oppositeBoundary.X);			maxX = Math.Max(location.x, oppositeBoundary.X);			minZ = mins.Max(i => i.Z);			maxZ = maxes.Min(i => i.Z);		}		//vertical		else if (zChange != 0)		{			minZ = Math.Min(location.z, oppositeBoundary.Z);			maxZ = Math.Max(location.z, oppositeBoundary.Z);			minX = mins.Max(i => i.X);			maxX = maxes.Min(i => i.X);		}		return new IlRect(minX, minZ, maxX, maxZ);	}	private IlPoint GetBoundaryInDirection(int startingX, int startingZ, int offsetX, int offsetZ, bool startingOnJigsaw,		ICollection<IlPoint>? trace = null)	{		var allowedToTakeJigsaw = !startingOnJigsaw;		while (true)		{			var newX = startingX + offsetX;			var newZ = startingZ + offsetZ;			if (!HasTile(newX, newZ))			{				return new IlPoint(startingX, startingZ);			}			if (Jigsaws.TryGetValue(new IlPoint(newX, newZ), out var jigsaw))			{				switch (jigsaw.TileType)				{					case JigsawTileType.North when allowedToTakeJigsaw:					case JigsawTileType.East when allowedToTakeJigsaw:					case JigsawTileType.South when allowedToTakeJigsaw:					case JigsawTileType.West when allowedToTakeJigsaw:						allowedToTakeJigsaw = false;						break;					default:						return new IlPoint(startingX, startingZ);				}			}			else			{				allowedToTakeJigsaw = true;			}			trace?.Add(new IlPoint(startingX, startingZ));			startingX = newX;			startingZ = newZ;		}	}	public bool IsCenter()	{		return Jigsaws.Values.All(j => j.PointingToLocation != null || j.PointsFromOutside);	}	public string SaveNbt(string fileName, string typeName)	{		var outputPath = $"output/data/poke-cities/structure/{typeName}";		if (!Directory.Exists(outputPath))		{			Directory.CreateDirectory(outputPath);		}		var path = $"{outputPath}/{fileName}-{Index}.nbt";		var nbt = new NbtFile(RootTag);		nbt.SaveToFile(path, NbtCompression.GZip);		Console.WriteLine($"Saved {path}");		return path;	}	public TemplatePool CreateTemplatePool(string fileName, string typeName)	{		return new TemplatePool(			"data/poke-cities/worldgen/template_pool",			$"{fileName}-{Index}",			new[]			{				new TemplatePoolElementWeight($"poke-cities:{typeName}/{fileName}-{Index}", 1)			}		);	}}